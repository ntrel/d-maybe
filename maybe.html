<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>maybe</title>
        </head><body>
        <h1>maybe</h1>
        <!-- Generated by Ddoc from maybe.d -->
<br><br>
<dl><dt><big>None <u>none</u>;
</big></dt>
<dd>Invalid value used for assignment/comparison with a Maybe instance.<br><br>

</dd>
<dt><big>struct <u>Maybe</u>(T);
</big></dt>
<dd>Contains either a value or nothing, guaranteeing the value is not accessible if invalid.
<br><br>
<b>Note:</b><br>
The abstraction can be circumvented using e.g. <u>Maybe</u>.valueOr(<b>null</b>), but at least
 this is explicit. <br><br>

<dl><dt><big>bool <u>opEquals</u>(T <i>v</i>);
</big></dt>
<dd>Tests whether the Maybe value is valid and equal to <i>v</i>.
<pre class="d_code"> <font color=blue>assert</font>(maybe(5) == 5);
 <font color=blue>assert</font>(maybe(5) != 6);
</pre>
<br><br>

</dd>
<dt><big>bool <u>opEquals</u>(Maybe!(T) <i>m</i>);
</big></dt>
<dd>Tests whether the Maybe value is valid, <i>m</i> is valid, and both values are equal.
<pre class="d_code"> <font color=blue>assert</font>(maybe(5) == maybe(5));
 <font color=blue>assert</font>(maybe(5) != maybe(6));
</pre>
<br><br>

</dd>
<dt><big>bool <u>opEquals</u>(None);
</big></dt>
<dd>Tests whether the Maybe value is invalid.
<pre class="d_code"> <font color=blue>assert</font>(Maybe!<font color=blue>int</font>() == none);
 <font color=blue>assert</font>(maybe(5) != none);
</pre>
<br><br>

</dd>
<dt><big>Maybe!(T) <u>filter</u>(scope bool delegate(T) <i>pred</i>);
</big></dt>
<dd>Returns a copy of the Maybe struct if <i>pred</i> returns <b>true</b>, or
 an invalid Maybe struct if <i>pred</i> returns <b>false</b>. <br><br>

</dd>
<dt><big>T <u>valueOr</u>(T <i>invalidValue</i>);
</big></dt>
<dd>Converts the Maybe value into a T, returning <i>invalidValue</i> if invalid.
 <i>invalidValue</i> can be <b>null</b>, but at least this is explicit:
<pre class="d_code"> Maybe!Object m = ...;
 Object w = m.<u>valueOr</u>(alternativeObject);
 Object v = m.<u>valueOr</u>(<font color=blue>null</font>);
</pre>
<br><br>
<b>Params:</b><br>
<table><tr><td>T <i>invalidValue</i></td>
<td>Value to return if the Maybe value is invalid.</td></tr>
</table><br>
<b>Note:</b><br>
It's safer to avoid using <u>valueOr</u> if possible.<br><br>

</dd>
</dl>
</dd>
<dt><big>template <u>match</u>(alias validFun,alias invalidFun) if (isInvalidFun!(invalidFun))<br>template <u>match</u>(alias invalidFun,alias validFun) if (isInvalidFun!(invalidFun))</big></dt>
<dd>Eponymous template.<br><br>

<dl><dt><big>auto <u>match</u>(Args...)(Args <i>args</i>);
</big></dt>
<dd>Attempts to call validFun(args), but with any Maybe instances in args unwrapped.
 If any Maybe instance in args is invalid, calls invalidFun() instead.
 invalidFun may return either void or the same type as validFun.
<br><br>
<b>Returns:</b><br>
The result of validFun/invalidFun, if any, wrapped in a Maybe.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"> <font color=blue>assert</font>(<u>match</u>!(to!string, ()=&gt;<font color=red>"&lt;invalid&gt;"</font>)(maybe(2)) == <font color=red>"2"</font>);
 <font color=blue>assert</font>(<u>match</u>!(to!string, ()=&gt;<font color=red>"&lt;invalid&gt;"</font>)(Maybe!<font color=blue>int</font>()) == <font color=red>"&lt;invalid&gt;"</font>);
 <font color=blue>assert</font>(<u>match</u>!(to!string, {})(maybe(2)) == <font color=red>"2"</font>);
 <font color=blue>assert</font>(<u>match</u>!(to!string, {})(Maybe!<font color=blue>int</font>()) == none);
 <font color=blue>assert</font>(<u>match</u>!((x, y)=&gt;text(x, y), {})(maybe(2), maybe(34)) == <font color=red>"234"</font>);
 <font color=blue>assert</font>(<u>match</u>!((x, y)=&gt;text(x, y), {})(Maybe!<font color=blue>int</font>(), maybe(34)) == none);
</pre>
 Arguments to <u>match</u> don't have to be Maybe instances:
<pre class="d_code"> <font color=blue>assert</font>(<u>match</u>!(text, {})(1, maybe(2), 3) == <font color=red>"123"</font>);
</pre>
 The order of validFun and invalidFun can be reversed:
<pre class="d_code"> <font color=blue>assert</font>(<u>match</u>!({}, text)(maybe('m')) == <font color=red>"m"</font>);
 <font color=blue>assert</font>(<u>match</u>!({}, text)(Maybe!<font color=blue>char</font>()) == none);
</pre>
<br><br>

</dd>
</dl>
</dd>
<dt><big>auto <u>matchVal</u>(alias validFun, alias invalidFun, Args...)(Args <i>args</i>);
</big></dt>
<dd>Attempts to call validFun(args), but with any Maybe instances in args unwrapped.
 If any Maybe instance in args is invalid, calls invalidFun() instead.
 invalidFun has to return the same type as validFun.
 The return type is not allowed to be a 'nullable' type like Object or float,
 which is why the result is not wrapped in a Maybe.
<br><br>
<b>Returns:</b><br>
The actual result of validFun/invalidFun.
<br><br>
<b>Example:</b><br>
<pre class="d_code"> <font color=blue>assert</font>(<u>matchVal</u>!(x=&gt;2*x, ()=&gt;-1)(maybe(4)) <font color=blue>is</font> 8);
 <font color=blue>assert</font>(<u>matchVal</u>!(x=&gt;2*x, ()=&gt;-1)(Maybe!<font color=blue>int</font>()) <font color=blue>is</font> -1);
</pre>
<br><br>

</dd>
<dt><big>template <u>attempt</u>(alias fun)</big></dt>
<dd>Eponymous template.<br><br>

<dl><dt><big>alias <u>attempt</u>;
</big></dt>
<dd>Attempts to call fun(args), but with any Maybe instances in args unwrapped.
 Does nothing if any Maybe instance in args is invalid.
 Equivalent to <tt>match!(fun, {})(args)</tt>.
<br><br>
<b>Returns:</b><br>
The result of fun, if any, wrapped in a Maybe.
<br><br>
<b>Example:</b><br>
<pre class="d_code"> <font color=blue>assert</font>(<u>attempt</u>!(x =&gt; 2*x)(maybe(5)) == 10);
 <font color=blue>assert</font>(<u>attempt</u>!text(maybe(<font color=red>"hi"</font>), 5) == <font color=red>"hi5"</font>);
 <font color=blue>assert</font>(<u>attempt</u>!text(6, Maybe!string()) == none);
</pre>
<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>. </small>
        </body></html>
